#version 330 core

// Input vertex data, different for all executions of this shader.
layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec2 vertexUV;
layout(location = 2) in vec3 vertexNormal_modelspace;

// Output data ; will be interpolated for each fragment.
out vec2 UV;
out vec3 Normal_cameraspace;
out vec3 color_magna;

// Values that stay constant for the whole mesh.
uniform mat4 MVP;
uniform mat4 V;
uniform mat4 M;
uniform mat3 MV3x3;
uniform sampler2D HeightMapSampler;
uniform ivec2 PlayerPosition;

void main(){
  int x = gl_InstanceID / 256;
  int z = gl_InstanceID % 256;
  vec3 tile_position = vertexPosition_modelspace; 

  float tex_x = (float(x) + tile_position.x/32)/257;
  float tex_y = (float(z) + tile_position.z/32)/257;
  tile_position.y = texture(HeightMapSampler, vec2(tex_x, tex_y)).r;
  tile_position.x += (PlayerPosition.x + x) * 32; 
  tile_position.z += (PlayerPosition.y + z) * 32; 

  vec3 normal = vec3(0, 1, 0);
  if (tex_x <= 128 && tex_y <= 128) {
    vec3 a = vec3(32, texture(HeightMapSampler, vec2(tex_x + 1, tex_y)).r, 0 );
    vec3 b = vec3(0 , texture(HeightMapSampler, vec2(tex_x, tex_y + 1)).r, 32);
    normal = cross(b, a);
  }

  // Output position of the vertex, in clip space : MVP * position
  gl_Position = MVP * vec4(tile_position, 1);
  
  // Normal_cameraspace = ( V * M * vec4(vertexNormal_modelspace,0)).xyz; 
  // Normal_cameraspace = (V * M * vec4(normal, 0)).xyz; 
  Normal_cameraspace = normal; 
  
  // UV of the vertex. No special space for this one.
  UV = vertexUV; 
  
  // model to camera = ModelView
  vec3 vertexNormal_cameraspace = MV3x3 * vertexNormal_modelspace;
}
