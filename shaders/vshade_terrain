#version 330 core

// Input vertex data, different for all executions of this shader.
layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec2 vertexUV;

// Output data ; will be interpolated for each fragment.
out vec2 UV;
out vec3 Normal_cameraspace;
out vec3 LightDirection_cameraspace;
out vec3 color_magna;

// Values that stay constant for the whole mesh.
uniform mat4 MVP;
uniform mat4 V;
uniform mat4 M;
uniform mat3 MV3x3;
uniform sampler2D HeightMapSampler;
uniform ivec2 PlayerPosition;

void main(){
  int x = gl_InstanceID / 32;
  int z = gl_InstanceID % 32;
  vec3 tile_position = vertexPosition_modelspace; 

  float tex_x = (float(x)*32 + tile_position.x/32)/1025;
  float tex_y = (float(z)*32 + tile_position.z/32)/1025;
  tile_position.y = texture(HeightMapSampler, vec2(tex_x, tex_y)).r;

  tile_position.x += (PlayerPosition.x + x) * 1024; 
  tile_position.z += (PlayerPosition.y + z) * 1024; 

  vec3 normal = vec3(0, 1, 0);
  if (tex_x <= 128 && tex_y <= 128) {
    vec3 a = vec3(32, texture(HeightMapSampler, vec2(tex_x + 1, tex_y)).r, 0 );
    vec3 b = vec3(0 , texture(HeightMapSampler, vec2(tex_x, tex_y + 1)).r, 32);
    normal = cross(b, a);
  }

  // Output position of the vertex, in clip space : MVP * position
  gl_Position = MVP * vec4(tile_position, 1);
  
  // Normal_cameraspace = ( V * M * vec4(vertexNormal_modelspace,0)).xyz; 
  Normal_cameraspace = ( V * M * vec4(normal,0)).xyz;
  
  // UV of the vertex. No special space for this one.
  UV = vertexUV; 
  
  // model to camera = ModelView
  // vec3 vertexNormal_cameraspace = MV3x3 * vertexNormal_modelspace;


  // Vector that goes from the vertex to the camera, in camera space.
  // In camera space, the camera is at the origin (0,0,0).
  vec3 vertexPosition_cameraspace = ( V * M * vec4(vertexPosition_modelspace,1)).xyz;
  vec3 EyeDirection_cameraspace = vec3(0,0,0) - vertexPosition_cameraspace;
  
  // Vector that goes from the vertex to the light, in camera space. M is ommited because it's identity.
  vec3 LightPosition_cameraspace = ( V * vec4(vertexPosition_modelspace.x, 1000000, vertexPosition_modelspace.z, 1)).xyz;
  LightDirection_cameraspace = LightPosition_cameraspace + EyeDirection_cameraspace;

  color_magna = texture(HeightMapSampler, vec2(tex_x, tex_y)).rgb;
  color_magna.r /= 128;
}
