#version 330 core

// Input vertex data, different for all executions of this shader.
layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec2 vertexUV;
layout(location = 2) in vec4 vertexBarycentric;

out FragData {
  vec3 position;
  vec2 UV;
  vec3 to_camera_vector;
  vec3 from_light_vector;
  vec4 clipSpace;
} out_data;

// Values that stay constant for the whole mesh.
uniform mat4 MVP;
uniform mat4 V;
uniform mat4 M;
uniform mat3 MV3x3;
uniform sampler2DRect NormalsSampler;
uniform sampler2DRect HeightMapSampler;
uniform ivec2 PlayerPosition;
uniform ivec2 buffer_top_left;
uniform ivec2 top_left;
uniform int PURE_TILE_SIZE;
uniform int TILE_SIZE;
uniform int CLIPMAP_SIZE;
uniform int MAX_HEIGHT;
uniform vec3 LightPosition_worldspace;
uniform vec3 cameraPosition;
uniform vec4 plane;
 
void main(){

  // Output position of the vertex, in clip space : MVP * position
  out_data.position = vertexPosition_modelspace;

  ivec2 toroidal_coords = ivec2(out_data.position.x, out_data.position.z);
  ivec2 buffer_coords = (toroidal_coords + buffer_top_left + CLIPMAP_SIZE + 1) % (CLIPMAP_SIZE + 1);
  float height = -(MAX_HEIGHT / 2) + MAX_HEIGHT * texelFetch(HeightMapSampler, buffer_coords).r;

  out_data.position.x *= TILE_SIZE;
  out_data.position.z *= TILE_SIZE;
  out_data.position.y = -100;

  vec3 position_worldspace = (M * vec4(out_data.position, 1)).xyz;
  // gl_ClipDistance[0] = dot(vec4(position_worldspace, 1.0), plane);

  out_data.clipSpace = MVP * vec4(out_data.position, 1);
  gl_Position = out_data.clipSpace;
  
  // UV of the vertex. No special space for this one.
  vec2 pos = position_worldspace.xz / PURE_TILE_SIZE;

  out_data.UV = pos / 32;
  out_data.to_camera_vector = cameraPosition - position_worldspace;
  out_data.from_light_vector = position_worldspace - LightPosition_worldspace;
}




// // Input vertex data, different for all executions of this shader.
// layout(location = 0) in vec3 vertexPosition_modelspace;
// layout(location = 1) in vec2 vertexUV;
// layout(location = 2) in vec3 vertexNormal_modelspace;
// layout(location = 3) in vec3 vertexTangent_modelspace;
// layout(location = 4) in vec3 vertexBitangent_modelspace;
// 
// // Output data ; will be interpolated for each fragment.
// out vec3 Position_worldspace;
// out vec3 EyeDirection_cameraspace;
// out vec3 LightDirection_cameraspace;
// out vec3 Normal_cameraspace;
// 
// out vec3 LightDirection_tangentspace;
// out vec3 EyeDirection_tangentspace;
// 
// // Values that stay constant for the whole mesh.
// uniform mat4 MVP;
// uniform mat4 V;
// uniform mat4 M;
// uniform mat3 MV3x3;
// uniform vec3 LightPosition_worldspace;
// uniform vec3 cameraPosition;
// 
// // uniform vec4 plane;
// out vec4 clipSpace;
// out vec2 textureCoords;
// out vec3 toCameraVector;
// out vec3 fromLightVector;
// 
// const float tiling = 10.0;
// 
// void main(){
//   // Position of the vertex, in worldspace : M * position
//   Position_worldspace = (M * vec4(vertexPosition_modelspace,1)).xyz;
//   
//   // gl_ClipDistance[0] = dot(vec4(Position_worldspace, 1.0), plane);
//   
//   // Output position of the vertex, in clip space : MVP * position
//   clipSpace = MVP * vec4(vertexPosition_modelspace,1);
//   gl_Position = clipSpace;
// 
//   textureCoords = vec2(vertexUV.x/2.0 + 0.5, vertexUV.y/2.0 + 0.5) * tiling;
//   toCameraVector = cameraPosition - Position_worldspace;
// 
//   fromLightVector = Position_worldspace.xyz - LightPosition_worldspace;
// }
